# 1.2 灰度处理  Grey-Level Processing

> **什么是灰度化？**  
> 		灰度化处理就是将一幅彩色图像转化为灰度图像的过程，就是使彩色图像的R、G、B分量相等的过程，即令R=G=B，此时的彩色表示的就是灰度颜色  
>   
> **为什么做图片处理要将彩色图像灰度化呢？**  
> 		图像灰度化的目的是为了简化矩阵，提高运算速度  
>   
> [为什么图片识别要将彩色图像灰度化？ - 知乎](https://zhuanlan.zhihu.com/p/355736102)  
> [图像处理基础(7)：图像的灰度变换 - Brook_icv - 博客园](https://www.cnblogs.com/wangguchangqing/p/6983680.html)  


## 灰度处理 Grey-Level Processing
### 1. 灰度变换的作用：
	1. 改善起始图像，使图像能够显示更多的细节，提高图像的对比度（对比度拉伸）
	2. 有选择的突出图像感兴趣的特征或者抑制图像中不需要的特征
	3. 可以有效的改变图像的直方图分布，使像素的分布更为均匀
也就是：
	* Restoration 改善
		* 什么是噪音，什么是信号？ 
		* 去除模糊blurring

	* Enhancement 增强
		* 强调必要的特征（如线性特征）
		* 强调变化 (如监督)


### 2. 灰度处理的方式
![](1.2%20%E7%81%B0%E5%BA%A6%E5%A4%84%E7%90%86%20%20Grey-Level%20Processing/%E6%88%AA%E5%B1%8F2021-04-11%2016.22.54.png)

### 2. 1 Point processing 点处理
	* **仅以单个像素值为基础对图像进行变换**
	* 将点与像素相对应
![](1.2%20%E7%81%B0%E5%BA%A6%E5%A4%84%E7%90%86%20%20Grey-Level%20Processing/%E6%88%AA%E5%B1%8F2021-04-11%2014.41.09.png)
灰度变换函数描述了输入灰度值和输出灰度值之间变换关系，一旦灰度变换函数确定下来了，那么其输出的灰度值也就确定了。可见灰度变换函数的性质就决定了灰度变换所能达到的效果

用于图像灰度变换的函数主要有以下几种：
	* 线性变换（增加/减少/扩展亮度和对比度）
	* 幂律变换（伽马变换）Gamma correction, power law
	*  图像之间的直方图匹配（*Histogram matching between images*）
	* **直方图平衡化**（*Histogram equalization*）
![](1.2%20%E7%81%B0%E5%BA%A6%E5%A4%84%E7%90%86%20%20Grey-Level%20Processing/%E6%88%AA%E5%B1%8F2021-04-11%2014.43.48.png)


#### 2.1.1 直方图平衡化（*Histogram equalization*）
	假如图像的灰度分布不均匀，其灰度分布集中在较窄的范围内，使图像的细节不够清晰，对比度较低。通常采用**直方图均衡化**及**直方图规定化**两种变换，使图像的灰度范围拉开或使灰度均匀分布，从而增大反差，使图像细节清晰，以达到增强的目的。
直方图均衡化，对图像进行非线性拉伸，重新分配图像的灰度值，使一定范围内图像的灰度值大致相等。这样，原来直方图中间的峰值部分对比度得到增强，而两侧的谷底部分对比度降低，输出图像的直方图是一个较为平坦的直方图

	如下面这张直方图，可以看到在黑色范围内有个很大的峰值，我们可以知道这是一个大部分为黑色的图片；我们可以使用histogram equalisation来平衡化直方图，为的是看到更黑的部分的细节（这里0为纯黑）
		* 	重新分配颜色，继续排序（从浅到深）
		* 增加对比度
		* n(i)：颜色i的像素数量
		* N：总数
		* f(i) = 1/N * 比i颜色深的像素的数量之和 = 比i颜色深的像素数量占总数量的比例
		* f(i) = 0.75，表示有75%的像素比这个深
![](1.2%20%E7%81%B0%E5%BA%A6%E5%A4%84%E7%90%86%20%20Grey-Level%20Processing/%E6%88%AA%E5%B1%8F2021-04-11%2014.59.04.png)
![](1.2%20%E7%81%B0%E5%BA%A6%E5%A4%84%E7%90%86%20%20Grey-Level%20Processing/%E6%88%AA%E5%B1%8F2021-04-11%2015.00.13.png)
![](1.2%20%E7%81%B0%E5%BA%A6%E5%A4%84%E7%90%86%20%20Grey-Level%20Processing/%E6%88%AA%E5%B1%8F2021-04-11%2015.00.33.png)


### 1.2 Neighbourhood Processing 邻域处理方法
	* 值及其上下文(局部上下文和处理)
	如果我们在图像中得到了两个黑色的像素，这对我们意味着什么？像素本身的意义不大，我们需要看它周围的情况。如果邻居是这样的（左图），那就说明这是一个黑色像素在一个嘈杂的黑暗区域；如果邻居是这样的（右图），那就说明这个黑色像素只是光照区域的噪声，所以我们可以把它处理掉
	在这里，我们一直认为邻域是围绕着3X3的区域(也有其他表示，如5x5)，称为结构元素(structuriing element, SE)
	用结构元素去除噪声有两种方法：
	* **Convolution** 
	* **Rank Filtering**

![](1.2%20%E7%81%B0%E5%BA%A6%E5%A4%84%E7%90%86%20%20Grey-Level%20Processing/%E6%88%AA%E5%B1%8F2021-04-11%2015.07.00.png)
#### 1.2.1 邻域处理方法：Convolution 卷积（用卷积去除噪声）
这里有一个一维的例子，用3个结构元素来做卷积，或一个卷积核，包含了元素1到1，这样就可以进行加权平均

![](1.2%20%E7%81%B0%E5%BA%A6%E5%A4%84%E7%90%86%20%20Grey-Level%20Processing/%E6%88%AA%E5%B1%8F2021-04-11%2015.22.04.png)
将每个元素乘以kernal的每个元素，然后相加之后再除以kernal的权重之和。如 (1*1+2*0+1*0.5)/4 =0.375。然后将kenral像窗口一样滑动，计算出数组的卷积值

2d卷积：
2d卷积和1d卷积差不多，只不过不会计算到边缘
![](1.2%20%E7%81%B0%E5%BA%A6%E5%A4%84%E7%90%86%20%20Grey-Level%20Processing/%E6%88%AA%E5%B1%8F2021-04-11%2015.37.01.png)
![](1.2%20%E7%81%B0%E5%BA%A6%E5%A4%84%E7%90%86%20%20Grey-Level%20Processing/%E6%88%AA%E5%B1%8F2021-04-11%2015.38.18.png)
![](1.2%20%E7%81%B0%E5%BA%A6%E5%A4%84%E7%90%86%20%20Grey-Level%20Processing/%E6%88%AA%E5%B1%8F2021-04-11%2015.40.34.png)
常见的卷积核有：
https://blog.csdn.net/jia20003/article/details/7294460
![](1.2%20%E7%81%B0%E5%BA%A6%E5%A4%84%E7%90%86%20%20Grey-Level%20Processing/%E6%88%AA%E5%B1%8F2021-04-11%2015.42.56.png)
![](1.2%20%E7%81%B0%E5%BA%A6%E5%A4%84%E7%90%86%20%20Grey-Level%20Processing/%E6%88%AA%E5%B1%8F2021-04-11%2016.00.23.png)
![](1.2%20%E7%81%B0%E5%BA%A6%E5%A4%84%E7%90%86%20%20Grey-Level%20Processing/%E6%88%AA%E5%B1%8F2021-04-11%2016.03.24.png)
[DoG (Difference of Gaussian)角点检测_Rachel Zhang的专栏-CSDN博客](https://blog.csdn.net/abcjennifer/article/details/7639488)
	DoG（Difference of Gauussians），高斯函数差分，是灰度图像增强和角点检测的方法。具体到图像处理来讲，就是将两幅图像在不同参数下的高斯滤波结果相减

![](1.2%20%E7%81%B0%E5%BA%A6%E5%A4%84%E7%90%86%20%20Grey-Level%20Processing/%E6%88%AA%E5%B1%8F2021-04-11%2016.03.33.png)
![](1.2%20%E7%81%B0%E5%BA%A6%E5%A4%84%E7%90%86%20%20Grey-Level%20Processing/%E6%88%AA%E5%B1%8F2021-04-11%2016.18.46.png)


#### 1.2.2 邻域处理方法：Rank Filtering 排名滤波
rank滤波器是使用局部灰度级排序来计算滤波值的非线性滤波器。这个滤波器的集合有一个共同的基础：局部灰度级直方图是在一个像素（由一个二维结构元素定义）的附近计算的。如果将过滤后的值作为直方图的中间值，我们就会得到经典的中值滤波器。

![](1.2%20%E7%81%B0%E5%BA%A6%E5%A4%84%E7%90%86%20%20Grey-Level%20Processing/%E6%88%AA%E5%B1%8F2021-04-11%2016.31.09.png)
![](1.2%20%E7%81%B0%E5%BA%A6%E5%A4%84%E7%90%86%20%20Grey-Level%20Processing/%E6%88%AA%E5%B1%8F2021-04-11%2016.32.08.png)


### Image Arithmetic 图像运算
	* 加法 Addition
		* 按顺序对图像取平均值
		* 减少噪声
![](1.2%20%E7%81%B0%E5%BA%A6%E5%A4%84%E7%90%86%20%20Grey-Level%20Processing/%E6%88%AA%E5%B1%8F2021-04-12%2016.38.20.png)
	
	* 减法 Subtraction
		* 相减
			* 如果是负数就Shift并映射到[0:255]
			* 或者作绝对值的差
		* 静态背景，检测笔爱花
		* 现实世界场景中的物体、阴影和反射
![](1.2%20%E7%81%B0%E5%BA%A6%E5%A4%84%E7%90%86%20%20Grey-Level%20Processing/%E6%88%AA%E5%B1%8F2021-04-12%2016.39.09.png)

	* 数字减影血管造影(DSA)
	* 研究前的X光片
	* 对照剂注射
	* 对比后的X光片
	* 差异 Difference

### Image Transforms 图像转换
	* 不同空间（频率空间）的图像